// =============================================================================
//                    TP 2 - FETCH Y FILESYSTEM 
// =============================================================================
// Programaci√≥n III - UNER
// Grupo: [N√öMERO]
// Integrantes: [NOMBRES Y APELLIDOS]
// =============================================================================

// Importo las librer√≠as necesarias para el proyecto
const fs = require('fs').promises; // Uso la versi√≥n con promesas para async/await
const path = require('path'); // Para manejar rutas de archivos de forma segura

// Constantes globales - las defino aqu√≠ para poder cambiarlas f√°cilmente
const API_BASE_URL = 'https://fakestoreapi.com';
const PRODUCTS_FILE = 'products.json';

/**
 * Clase principal que maneja todas las operaciones con productos
 * Decid√≠ usar una clase porque agrupa todas las funcionalidades relacionadas
 * y me permite mantener el estado (como la URL de la API y la ruta del archivo)
 */
class ProductManager {
    constructor() {
        this.apiUrl = API_BASE_URL;
        // Uso path.join para crear la ruta completa del archivo de forma segura
        this.filePath = path.join(__dirname, PRODUCTS_FILE);
    }

    /**
     * Funci√≥n auxiliar para crear separadores visuales en la consola
     * La cre√© porque me parece importante que la salida sea clara y organizada
     */
    printSeparator(title = '', symbol = '=', length = 60) {
        if (title) {
            // Calculo el padding para centrar el t√≠tulo
            const padding = Math.max(0, Math.floor((length - title.length - 2) / 2));
            console.log(symbol.repeat(padding) + ` ${title} ` + symbol.repeat(padding));
        } else {
            console.log(symbol.repeat(length));
        }
    }

    /**
     * Funci√≥n para mostrar productos de forma organizada
     * Limito la cantidad mostrada para no sobrecargar la consola
     */
    displayProducts(products, title = 'Productos', maxShow = 3) {
        console.log(`\nüì¶ ${title}:`);
        console.log('‚îÄ'.repeat(50));
        
        // Solo muestro los primeros productos para mantener la salida limpia
        const showProducts = products.slice(0, maxShow);
        showProducts.forEach((product, index) => {
            // Uso emojis para hacer m√°s visual la informaci√≥n con(win + .)
            console.log(`${index + 1}. üõçÔ∏è  ${product.title}`);
            console.log(`   üí∞ Precio: $${product.price}`);
            console.log(`   üìÇ Categor√≠a: ${product.category}`);
            console.log(`   üÜî ID: ${product.id}`);
            // Agrego separaci√≥n entre productos excepto en el √∫ltimo
            if (index < showProducts.length - 1) console.log('');
        });
        
        // Informo si hay m√°s productos que no se muestran
        if (products.length > maxShow) {
            console.log(`   ... y ${products.length - maxShow} productos m√°s`);
        }
        console.log('‚îÄ'.repeat(50));
    }

    /**
     * Funci√≥n para mostrar el resultado de cada operaci√≥n de forma consistente
     * Me ayuda a tener un feedback uniforme de todas las operaciones
     */
    displayOperation(operation, success, data = null, details = '') {
        const emoji = success ? '‚úÖ' : '‚ùå';
        const status = success ? '√âXITO' : 'ERROR';
        
        console.log(`\n${emoji} ${operation} - ${status}`);
        if (details) console.log(`   üìù ${details}`);
        
        // Muestro informaci√≥n adicional seg√∫n el tipo de dato
        if (success && data) {
            if (Array.isArray(data)) {
                console.log(`   üìä Cantidad: ${data.length} elementos`);
            } else if (typeof data === 'object') {
                // Muestro propiedades b√°sicas del objeto si existen
                console.log(`   üÜî ID: ${data.id || 'N/A'}`);
                if (data.title) console.log(`   üìå T√≠tulo: ${data.title}`);
                if (data.price) console.log(`   üí∞ Precio: $${data.price}`);
            }
        }
    }

    /**
     * Funci√≥n auxiliar centralizada para hacer peticiones HTTP
     * La cre√© para no repetir c√≥digo y manejar errores de forma consistente
     */
    async makeRequest(url, options = {}) {
        try {
            const response = await fetch(url, {
                headers: {
                    // Siempre env√≠o Content-Type JSON para las peticiones
                    'Content-Type': 'application/json',
                    ...options.headers // Permite agregar headers adicionales
                },
                ...options
            });
            
            // Verifico si la respuesta es exitosa antes de procesarla
            if (!response.ok) {
                throw new Error(`HTTP Error: ${response.status} - ${response.statusText}`);
            }
            
            return await response.json();
        } catch (error) {
            console.error('‚ùå Error en la petici√≥n:', error.message);
            throw error; // Re-lanzo el error para que lo maneje la funci√≥n que llama
        }
    }

    /**
     * 1. GET - Recuperar todos los productos de la API
     * Esta es la operaci√≥n m√°s b√°sica del CRUD
     */
    async getAllProducts() {
        try {
            console.log('üîÑ Obteniendo todos los productos...');
            const products = await this.makeRequest(`${this.apiUrl}/products`);
            
            this.displayOperation(
                'GET Todos los Productos', 
                true, 
                products, 
                `Se obtuvieron ${products.length} productos de la API`
            );
            
            // Muestro solo los primeros para no saturar la consola
            this.displayProducts(products, 'Primeros 3 Productos');
            return products;
        } catch (error) {
            this.displayOperation('GET Todos los Productos', false, null, error.message);
            return null; // Retorno null para indicar fallo
        }
    }

    /**
     * 2. GET - Recuperar n√∫mero limitado de productos
     * Uso query parameters para limitar la cantidad
     */
    async getLimitedProducts(limit = 5) {
        try {
            console.log(`üîÑ Obteniendo ${limit} productos limitados...`);
            // Uso query parameter ?limit= como indica la documentaci√≥n de la API
            const products = await this.makeRequest(`${this.apiUrl}/products?limit=${limit}`);
            
            this.displayOperation(
                'GET Productos Limitados', 
                true, 
                products, 
                `Se obtuvieron ${products.length} productos con l√≠mite de ${limit}`
            );
            
            this.displayProducts(products, 'Productos Limitados', limit);
            return products;
        } catch (error) {
            this.displayOperation('GET Productos Limitados', false, null, error.message);
            return null;
        }
    }

    /**
     * 3. Persistir datos en archivo JSON local
     * Uso JSON.stringify con indentaci√≥n para que sea legible
     */
    async saveProductsToFile(products) {
        try {
            console.log('üîÑ Guardando productos en archivo local...');
            // Uso null, 2 para formatear el JSON con indentaci√≥n
            await fs.writeFile(this.filePath, JSON.stringify(products, null, 2), 'utf8');
            
            this.displayOperation(
                'Guardar en Archivo JSON', 
                true, 
                products, 
                `${products.length} productos guardados en ${PRODUCTS_FILE}`
            );
        } catch (error) {
            this.displayOperation('Guardar en Archivo JSON', false, null, error.message);
        }
    }

    /**
     * 4. POST - Agregar nuevo producto a la API
     * Env√≠o los datos en el body como JSON
     */
    async addNewProduct(productData) {
        try {
            console.log('üîÑ Agregando nuevo producto...');
            const newProduct = await this.makeRequest(`${this.apiUrl}/products`, {
                method: 'POST',
                body: JSON.stringify(productData) // Convierto el objeto a JSON
            });
            
            this.displayOperation(
                'POST Nuevo Producto', 
                true, 
                newProduct, 
                'Producto creado exitosamente en la API'
            );
            
            return newProduct;
        } catch (error) {
            this.displayOperation('POST Nuevo Producto', false, null, error.message);
            return null;
        }
    }

    /**
     * 5. GET - Buscar producto por ID espec√≠fico
     * Uso el ID como par√°metro en la URL
     */
    async getProductById(id) {
        try {
            console.log(`üîÑ Buscando producto con ID: ${id}...`);
            // El ID va en la URL como par√°metro de ruta
            const product = await this.makeRequest(`${this.apiUrl}/products/${id}`);
            
            this.displayOperation(
                'GET Producto por ID', 
                true, 
                product, 
                `Producto encontrado con ID ${id}`
            );
            
            return product;
        } catch (error) {
            this.displayOperation('GET Producto por ID', false, null, error.message);
            return null;
        }
    }

    /**
     * 6. DELETE - Eliminar producto de la API
     * Solo necesito enviar el m√©todo DELETE con el ID
     */
    async deleteProduct(id) {
        try {
            console.log(`üîÑ Eliminando producto con ID: ${id}...`);
            const result = await this.makeRequest(`${this.apiUrl}/products/${id}`, {
                method: 'DELETE'
            });
            
            this.displayOperation(
                'DELETE Producto', 
                true, 
                result, 
                `Producto con ID ${id} eliminado de la API`
            );
            
            return result;
        } catch (error) {
            this.displayOperation('DELETE Producto', false, null, error.message);
            return null;
        }
    }

    /**
     * 7. PUT - Modificar producto existente en la API
     * Env√≠o los datos actualizados en el body
     */
    async updateProduct(id, productData) {
        try {
            console.log(`üîÑ Modificando producto con ID: ${id}...`);
            const updatedProduct = await this.makeRequest(`${this.apiUrl}/products/${id}`, {
                method: 'PUT',
                body: JSON.stringify(productData)
            });
            
            this.displayOperation(
                'PUT Actualizar Producto', 
                true, 
                updatedProduct, 
                `Producto con ID ${id} actualizado exitosamente`
            );
            
            return updatedProduct;
        } catch (error) {
            this.displayOperation('PUT Actualizar Producto', false, null, error.message);
            return null;
        }
    }

    /**
     * FileSystem - Leer productos del archivo local
     * Manejo el caso donde el archivo no existe
     */
    async readProductsFromFile() {
        try {
            const data = await fs.readFile(this.filePath, 'utf8');
            return JSON.parse(data);
        } catch (error) {
            // Si el archivo no existe, retorno array vac√≠o en lugar de error
            if (error.code === 'ENOENT') {
                console.log('üìÑ Archivo no existe, retornando array vac√≠o');
                return [];
            }
            throw error; // Otros errores s√≠ los propago
        }
    }

    /**
     * FileSystem - Agregar producto al archivo local
     * Genero un ID √∫nico para el nuevo producto
     */
    async addProductToLocalFile(newProduct) {
        try {
            console.log('üîÑ Agregando producto al archivo local...');
            const existingProducts = await this.readProductsFromFile();
            
            // Genero un ID √∫nico basado en el m√°ximo existente + 1
            const maxId = existingProducts.length > 0 
                ? Math.max(...existingProducts.map(p => p.id || 0))
                : 0;
            
            const productToAdd = {
                id: maxId + 1,
                ...newProduct // Uso spread operator para copiar todas las propiedades
            };
            
            existingProducts.push(productToAdd);
            await this.saveProductsToFile(existingProducts);
            
            this.displayOperation(
                'Agregar Producto Local', 
                true, 
                productToAdd, 
                'Producto agregado al archivo local exitosamente'
            );
            
            return productToAdd;
        } catch (error) {
            this.displayOperation('Agregar Producto Local', false, null, error.message);
            return null;
        }
    }

    /**
     * FileSystem - Eliminar productos con precio superior al l√≠mite
     * Uso filter() para crear un nuevo array con solo los productos v√°lidos
     */
    async removeProductsAbovePrice(maxPrice) {
        try {
            console.log(`üîÑ Eliminando productos con precio superior a $${maxPrice}...`);
            const products = await this.readProductsFromFile();
            const initialCount = products.length;
            
            // Filtro productos que tengan precio menor o igual al m√°ximo
            const filteredProducts = products.filter(product => {
                const price = parseFloat(product.price);
                // Incluyo solo si el precio es v√°lido y menor/igual al m√°ximo
                return !isNaN(price) && price <= maxPrice;
            });
            
            const removedCount = initialCount - filteredProducts.length;
            await this.saveProductsToFile(filteredProducts);
            
            console.log(`\n‚úÖ Filtrado de Productos por Precio - √âXITO`);
            console.log(`   üìä Productos eliminados: ${removedCount}`);
            console.log(`   üì¶ Productos restantes: ${filteredProducts.length}`);
            console.log(`   üí∞ Precio m√°ximo permitido: $${maxPrice}`);
            
            return {
                removed: removedCount,
                remaining: filteredProducts.length,
                products: filteredProducts
            };
        } catch (error) {
            this.displayOperation('Filtrado por Precio', false, null, error.message);
            return null;
        }
    }

    /**
     * Funci√≥n adicional para mostrar estad√≠sticas del archivo
     * La agregu√© para tener mejor visibilidad de los datos locales
     */
    async showLocalFileStats() {
        console.log('\n');
        this.printSeparator('ESTAD√çSTICAS DEL ARCHIVO LOCAL', '‚ñà', 60);
        
        try {
            const products = await this.readProductsFromFile();
            
            if (products.length === 0) {
                console.log('\nüìÑ El archivo est√° vac√≠o o no existe\n');
                return;
            }
            
            // Calculo estad√≠sticas de precios
            const prices = products.map(p => parseFloat(p.price)).filter(p => !isNaN(p));
            
            console.log(`\nüìä RESUMEN GENERAL:`);
            console.log(`   üì¶ Total de productos: ${products.length}`);
            
            if (prices.length > 0) {
                const average = prices.reduce((a, b) => a + b, 0) / prices.length;
                console.log(`   üí∞ Precio promedio: $${average.toFixed(2)}`);
                console.log(`   üíé Precio m√°ximo: $${Math.max(...prices).toFixed(2)}`);
                console.log(`   üí∏ Precio m√≠nimo: $${Math.min(...prices).toFixed(2)}`);
            }
            
            // Muestro listado completo de productos
            console.log(`\nüõçÔ∏è LISTADO DE PRODUCTOS:`);
            console.log('‚îÄ'.repeat(60));
            
            products.forEach((product, index) => {
                const number = (index + 1).toString().padStart(2, '0');
                // Limito la longitud del t√≠tulo para mantener formato
                const title = product.title.length > 35 
                    ? product.title.substring(0, 35) + '...' 
                    : product.title;
                const price = `$${parseFloat(product.price).toFixed(2)}`;
                
                // Uso padEnd y padStart para alinear columnas
                console.log(`${number}. ${title.padEnd(38)} ${price.padStart(8)}`);
            });
            
            console.log('‚îÄ'.repeat(60));
        } catch (error) {
            this.displayOperation('Mostrar Estad√≠sticas', false, null, error.message);
        }
    }
}

/**
 * Funci√≥n principal que ejecuta todas las tareas del TP
 * La organic√© en dos partes: API y FileSystem, como pide la consigna
 */
async function main() {
    const productManager = new ProductManager();
    
    // Header principal del programa
    console.log('\n');
    console.log('‚ñà'.repeat(70));
    console.log('‚ñà'.repeat(20) + '  TP 2 - FETCH Y FILESYSTEM  ' + '‚ñà'.repeat(20));
    console.log('‚ñà'.repeat(70));
    console.log('üìö Programaci√≥n III - UNER');
    console.log('üéØ Trabajo Pr√°ctico de APIs y Manejo de Archivos');
    console.log('‚ñà'.repeat(70));
    
    try {
        // =================================================================
        // PARTE 1: OPERACIONES CON LA API
        // =================================================================
        console.log('\n');
        productManager.printSeparator('PARTE 1: OPERACIONES API', '‚ñì', 60);
        
        // 1. Obtener todos los productos
        const allProducts = await productManager.getAllProducts();
        await new Promise(resolve => setTimeout(resolve, 1000)); 
        
        // 2. Obtener productos limitados (5)
        const limitedProducts = await productManager.getLimitedProducts(5);
        await new Promise(resolve => setTimeout(resolve, 1000));
        
        // 3. Guardar productos en archivo JSON
        if (limitedProducts) {
            await productManager.saveProductsToFile(limitedProducts);
        }
        await new Promise(resolve => setTimeout(resolve, 1000));
        
        // 4. Crear nuevo producto
        const newProductData = {
            title: 'Producto de Prueba TP2',
            price: 25.99,
            description: 'Producto creado para el TP2 de Programaci√≥n III',
            image: 'https://fakestoreapi.com/img/placeholder.jpg',
            category: 'test'
        };
        
        await productManager.addNewProduct(newProductData);
        await new Promise(resolve => setTimeout(resolve, 1000));
        
        // 5. Buscar producto por ID
        await productManager.getProductById(1);
        await new Promise(resolve => setTimeout(resolve, 1000));
        
        // 6. Eliminar producto
        await productManager.deleteProduct(1);
        await new Promise(resolve => setTimeout(resolve, 1000));
        
        // 7. Actualizar producto
        const updateData = {
            title: 'Producto Modificado TP2',
            price: 15.99,
            description: 'Producto modificado en el TP2'
        };
        await productManager.updateProduct(2, updateData);
        
        // =================================================================
        // PARTE 2: OPERACIONES CON FILESYSTEM
        // =================================================================
        console.log('\n');
        productManager.printSeparator('PARTE 2: OPERACIONES FILESYSTEM', '‚ñì', 60);
        
        // 8. Agregar producto al archivo local
        const localProduct = {
            title: 'Producto Local TP2',
            price: 45.00,
            description: 'Producto agregado directamente al archivo local',
            category: 'local'
        };
        
        await productManager.addProductToLocalFile(localProduct);
        await new Promise(resolve => setTimeout(resolve, 1000));
        
        // 9. Mostrar estad√≠sticas del archivo
        await productManager.showLocalFileStats();
        await new Promise(resolve => setTimeout(resolve, 1500));
        
        // 10. Eliminar productos caros (precio > $30)
        await productManager.removeProductsAbovePrice(30);
        await new Promise(resolve => setTimeout(resolve, 1000));
        
        // 11. Mostrar estad√≠sticas finales
        await productManager.showLocalFileStats();
        
        // Footer final
        console.log('\n');
        console.log('‚ñà'.repeat(70));
        console.log('‚ñà'.repeat(25) + '  ‚úÖ COMPLETADO  ' + '‚ñà'.repeat(25));
        console.log('‚ñà'.repeat(70));
        console.log('üéâ TP2 ejecutado exitosamente');
        console.log('üìÑ Archivo products.json generado correctamente');
        console.log('‚ú® Todas las funcionalidades implementadas');
        console.log('‚ñà'.repeat(70));
        
    } catch (error) {
        // Manejo de errores globales
        console.error('\nüí• Error general en la ejecuci√≥n:', error.message);
        console.log('‚ñà'.repeat(70));
    }
}

// Ejecuto el programa solo si es el archivo principal
// Esto permite importar la clase sin ejecutar main()
if (require.main === module) {
    main().catch(console.error);
}

// Exporto la clase para poder usarla en otros archivos
module.exports = ProductManager;